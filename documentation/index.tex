%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Primordial Machine's Math Matrices Library
% Copyright (C) 2017-2019 Michael Heilmann
%
% This software is provided 'as-is', without any express or implied warranty.
% In no event will the authors be held liable for any damages arising from the
% use of this software.
%
% Permission is granted to anyone to use this software for any purpose,
% including commercial applications, and to alter it and redistribute it
% freely, subject to the following restrictions:
%
% 1. The origin of this software must not be misrepresented;
%    you must not claim that you wrote the original software.
%    If you use this software in a product, an acknowledgment
%    in the product documentation would be appreciated but is not required.
%
% 2. Altered source versions must be plainly marked as such,
%    and must not be misrepresented as being the original software.
%
% 3. This notice may not be removed or altered from any source distribution.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[oneside]{book}

\input{common}

\SetOrganization{Primordial Machine's}
\SetLibraryName{Math Matrices Library}

\SetLibraryIncludeFileName{include.hpp}
\SetLibraryIncludesDirectoryPath{primordialmachine/math-matrices/\newline\$(PlatformTarget.toLower())/\$(Configuration.toLower())/includes}

\SetLibraryIncludeDirectiveFilePath{primordialmachine/math/matrices/include.hpp}

\SetLibraryStaticLibrariesDirectoryPath{primordialmachine/math-matrices/\newline\$(PlatformTarget.toLower())/\$(Configuration.toLower())/libraries}
\SetLibraryStaticLibraryFileName{math-matrices.lib}

\SetLibraryVersion{v1.0}
\SetLibraryRepository{https://github.com/primordialmachine/math-matrices}
\SetAuthor{Michael Heilmann}
\SetEmail{michaelheilmann@primordialmachine.com}

\SetDocumentType{User Manual}

\begin{document}

\frontmatter

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents
\addtocontents{toc}{\protect\thispagestyle{empty}}
\pagenumbering{gobble}

\mainmatter

\chapter{Synopsis}
C++ 17 library providing floating point vectors over $n$ dimensions.
The library is made available publicly on
\href{\GetLibraryRepository}{Github}
under the
\href{\GetLibraryRepository/blob/master/LICENSE}{MIT License}.

\chapter{Limitations and Restrictions}
The library officially only supports Visual Studio 2017 and Windows 10.

\chapter{Introductory example}
\textit{\color{orange}This library does not provide any examples yet.}
%Examples are located in the \href{\GetLibraryRepository/blob/master/examples}{examples} directory.

\input{building_visual_studio_2017}

\chapter{Library Interface Documentation}

\section{\texttt{namespace primordialmachine}}
The namespace this library is adding its declarations/definitions to.
The added namespace elements are documented below.

\input{functors}
\input{binary_functor}

\section{\texttt{matrix\_traits} (struct)}
\begin{verbatim}
template<typename ELEMENT_TYPE, size_t NUMBER_OF_COLUMNS, size_t NUMBER_OF_ROWS>
struct matrix_traits;
\end{verbatim}

\section{\texttt{is\_matrix} (struct)}
\texttt{
template \textlangle class TYPE, typename ENABLED = void\textrangle\newline
struct is\_matrix {\newline
  static bool const value = false;\newline
};}

\noindent{}This template defines a compile-time boolean constant \texttt{value}
which can be used to determine whether a type \texttt{TYPE} is a valid vector type.
This library provides specialization for its \texttt{matrix} template specializations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{matrix} (struct)}
\begin{verbatim}
template<typename TRAITS, typename ENABLED = void>
struct matrix;
\end{verbatim}
\noindent{}This library provides specializations where \texttt{TRAITS} is a \texttt{matrix\_traits}
specialization with the following properties:
\begin{enumerate}
	\item \texttt{ELEMENT\_TYPE} is a type \texttt{TYPE} for which \texttt{is\_scalar\textlangle TYPE \textrangle::value} is \texttt{true}.
	\item \texttt{NUMBER\_OF\_ROWS} and \texttt{NUMBER\_OF\_COLUMNS} each are of any number between 0 and
	\texttt{std::numeric\_limits\textlangle size\_t\textrangle\::max()}.
\end{enumerate}

\section{Members}

\section{Non members}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\texttt{operator+} (binary, matrix matrix)}
Compute the sum of two matrices.
\begin{verbatim}
template<typename A, typename B>
typename binary_plus_functor<matrix<A>, matrix<B>>::result_type
operator+(const matrix<A>& a, const matrix<B>& b)
{ return binary_plus_functor<matrix<A>, matrix<B>>()(a, b); }
\end{verbatim}
This library provides a specializations for \texttt{matrix\textlangle A\textrangle}
and \texttt{matrix\textlangle B\textrangle} where
\begin{enumerate}
	\item \texttt{A::number\_of\_rows} is equal to \texttt{B::number\_of\_rows},
    \item \texttt{B::number\_of\_columns} is equal to \texttt{B::number\_of\_columns}, and
	\item \texttt{A::element\_type} and \texttt{B::element\_type} are floating point types.
\end{enumerate}

\subsubsection{\texttt{operator+} (unary, matrix)}
Compute the affirmation of a matrix.
\begin{verbatim}
template<typename A>
typename unary_plus_functor<matrix<A>>::result_type
operator+(const matrix<A>& a)
{ return unary_plus_functor<matrix<A>>()(a); }
\end{verbatim}
This library provides a specializations for \texttt{matrix\textlangle A
\textrangle} where  \texttt{A::element\_type} is a floating point type.

\subsubsection{\texttt{operator+=} (compound binary, matrix matrix)}
Compute the sum of two matrices, assign the result to the first operand.
\begin{verbatim}
template<typename A, typename B>
auto
operator-=(matrix<A>& a, const matrix<B>& b)
{
   a = a + b;
   return a;
}
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\texttt{operator-} (binary, matrix matrix)}
Compute the difference of two matrices.
\begin{verbatim}
template<typename A, typename B>
typename binary_minus_functor<matrix<A>, matrix<B>>::result_type
operator-(const matrix<A>& a, const matrix<B>& b)
{ return binary_minus_functor<vector<A>, vector<B>>()(a, b); }
\end{verbatim}
This library provides a specializations for \texttt{matrix\textlangle A\textrangle}
and \texttt{vector\textlangle B\textrangle} where
\begin{enumerate}
	\item \texttt{A::number\_of\_rows} is equal to \texttt{B::number\_of\_rows},
	\item \texttt{A::number\_of\_columns} is equal to \texttt{B::number\_of\_columns}, and
	\item \texttt{A::element\_type} and \texttt{B::element\_type} are floating point types.
\end{enumerate}

\subsubsection{\texttt{operator-} (unary, matrix)}
Compute the negation of a matrix.
\begin{verbatim}
template<typename A>
typename unary_minus_functor<matrix<A>>::result_type
operator-(const matrix<A>& a)
{ return unary_minus_functor<matrix<A>>()(a); }
\end{verbatim}
This library provides a specializations for \texttt{matrix\textlangle A
\textrangle} where  \texttt{A::element\_type} is a floating point type.

\subsubsection{\texttt{operator-=} (compound binary, matrix matrix)}
Compute the difference of two matrices, assign the result to the left operand.
\begin{verbatim}
template<typename A, typename B>
auto&
operator-=(matrix<A>& a, const matrix<B>& b)
{
   a = a - b;
   return a;
}
\end{verbatim}

\subsection{\texttt{inverse\_functor} (struct)}
An \textit{UnaryFunctorBase} computing the inverse of a matrix.
A possible implementation is given by
\begin{verbatim}
template<typename OPERAND, typename ENABLED = void>
struct transpose_functor;
\end{verbatim}

\noindent{}\noindent{}This library provides \textit{UnaryFunctor} specializations of this \textit{UnaryFunctorBase}
where \texttt{OPERAND} is a type which fulfils the \textit{NonDegenerateMatrix} and \textit{SquareMatrix} concepts.
\newline

\noindent{}The result type \texttt{result\_type} is \texttt{matrix\textlangle OPERAND::traits\_type\textrangle}.

\subsubsection{\texttt{inverse} (function)}
This library provides a function to invoke the \texttt{inverse\_functor}.
A possible implementation is given by\newline
\texttt{
template\textlangle typename OPERAND\textrangle\newline
auto inverse(const OPERAND\& operand)\newline
-> decltype(inverse\_functor\textlangle OPERAND\textrangle()(operand))\newline
\{ return inverse\_functor\textlangle OPERAND\textrangle()(operand); \}
}

\subsection{\texttt{transpose\_functor} (struct)}
An \textit{UnaryFunctorBase} computing the transpose of a matrix.
A possible implementation is given by
\begin{verbatim}
template<typename OPERAND, typename ENABLED = void>
struct transpose_functor;
\end{verbatim}

\noindent{}This library provides \textit{UnaryFunctor} specializations of this
\textit{UnaryFunctorBase} where \texttt{OPERAND} is a type which fulfils   the
\textit{Matrix} concept.\newline

\noindent{}The result type \texttt{result\_type} is\newline
\texttt{matrix\textlangle   OPERAND::traits\_type::element\_type,\newline
\hphantom{matrix\textlangle}OPERAND::traits\_type::number\_of\_columns,\newline
\hphantom{matrix\textlangle}OPERAND::traits\_type::number\_of\_rows\textrangle}\newline

\noindent{}Note that the number of rows and columns of the result type are swapped.

\subsubsection{\texttt{transpose} (function)}
This library provides a function to invoke the \texttt{transpose\_functor}.
A possible implementation is given by\newline
\texttt{
template\textlangle typename OPERAND\textrangle\newline
auto transpose(const OPERAND\& operand)\newline
-> decltype(transpose\_functor\textlangle OPERAND\textrangle()(operand))\newline
\{ return transpose\_functor\textlangle OPERAND\textrangle()(operand); \}
}

\subsection{\texttt{trace\_functor} (struct)}
An \textit{UnaryFunctorBase} compute the trace of a matrix.
A possible implementation is given by
\begin{verbatim}
template<typename OPERAND, typename ENABLED = void>
struct trace_functor;
\end{verbatim}

\noindent{}This library provides \textit{UnaryFunctor} specializations of this
\textit{UnaryFunctorBase} where \texttt{OPERAND} is a type which fulfils   the
\textit{NonDegenerateMatrix} concept.\newline

\noindent{}The result type \texttt{result\_type} is \texttt{OPERAND\_TRAITS::element\_type}.

\subsubsection{\texttt{trace} (function)}
This library provides a function to invoke the \texttt{trace\_functor}.
A possible implementation is given by\newline
\texttt{
template\textlangle typename OPERAND\textrangle\newline
auto trace(const OPERAND\& operand)\newline
-> decltype(trace\_functor\textlangle OPERAND\textrangle()(operand))\newline
\{ return trace\_functor\textlangle OPERAND\textrangle()(operand); \}
}


\end{document}
